================================================================================
 üêî CHINA'S DEVELOPMENT WORKFLOW EGG #005 ü•ö
================================================================================

üèóÔ∏è BASHFX 2.1 DEVELOPMENT WORKFLOW GUIDE
=========================================

üìã EGG METADATA
----------------
Date Created: 2024-09-17 15:48 UTC
Agent: China the Summary Chicken üêî
Target: GitSim BashFX 2.1 Development Workflow & Best Practices
User Request: Comprehensive development workflow documentation

üéØ EXECUTIVE SUMMARY
====================
GitSim follows BashFX 2.1 development patterns with modular source code, automated
builds, and comprehensive testing. This workflow enables maintainable development
of complex bash applications while ensuring production quality and reliability.

‚ú® CRITICAL DISCOVERY: PROFESSIONAL BASH DEVELOPMENT
====================================================
+-------------------------------------------------------+
| BASHFX 2.1 TRANSFORMS BASH FROM SCRIPTING TO SOFTWARE ENGINEERING |
+-------------------------------------------------------+

This project demonstrates enterprise-grade bash development:
- Modular source code (parts/ directory)
- Automated build and test pipelines
- Professional version control practices
- Comprehensive error handling and validation

üîß CORE DEVELOPMENT PRINCIPLES
==============================

**1. VALIDATION-FIRST APPROACH**
- Always test functionality before optimization
- Modular validation: test each component independently
- Document issues clearly: blocking vs. non-blocking
- Show that everything works, then optimize

**2. BASHFX ARCHITECTURE COMPLIANCE**
- BashFX 2.1 is the gold standard for scripts 500+ lines
- Edit parts/, not the final script
- Use build.map + parts/ structure for maintainability
- Validate syntax and functionality after each build

**3. MODULAR BUILD PATTERNS**
- Check for function duplication (later parts override earlier ones)
- Validate execution order for dynamic registration systems
- Monitor script size growth, warn at thresholds
- Clean test artifacts between development phases

üõ†Ô∏è PROJECT STRUCTURE WORKFLOW
==============================

**BashFX 2.1 Project Layout:**
```
fx-gitsim/
‚îú‚îÄ‚îÄ build.sh              # Build orchestrator (DON'T EDIT gitsim.sh)
‚îú‚îÄ‚îÄ parts/                 # Source code modules (EDIT THESE)
‚îÇ   ‚îú‚îÄ‚îÄ build.map         # Build order specification
‚îÇ   ‚îú‚îÄ‚îÄ part_01_*.sh      # Infrastructure components
‚îÇ   ‚îú‚îÄ‚îÄ part_13-17_*.sh   # Feature modules (templates)
‚îÇ   ‚îú‚îÄ‚îÄ part_69-80_*.sh   # Command dispatchers
‚îÇ   ‚îî‚îÄ‚îÄ part_99_*.sh      # Main entry point
‚îú‚îÄ‚îÄ gitsim.sh             # Generated artifact (build output)
‚îú‚îÄ‚îÄ test_runner.sh        # Comprehensive test suite
‚îú‚îÄ‚îÄ CLAUDE.md             # Development patterns & insights
‚îú‚îÄ‚îÄ SESSION.md            # Development session notes
‚îî‚îÄ‚îÄ README.md             # User documentation
```

üîÑ DEVELOPMENT CYCLE WORKFLOW
=============================

**Phase 1: Planning & Analysis**
```bash
# 1. Read existing documentation
cat CLAUDE.md SESSION.md README.md

# 2. Understand current architecture
ls parts/ && cat parts/build.map

# 3. Plan changes (update SESSION.md)
```

**Phase 2: Implementation**
```bash
# 1. Create/edit parts (NEVER edit gitsim.sh directly)
vim parts/part_XX_new_feature.sh

# 2. Update build.map if adding new parts
echo "XX : part_XX_new_feature.sh" >> parts/build.map

# 3. Build the project
./build.sh

# 4. Validate syntax and basic functionality
bash -n gitsim.sh && ./gitsim.sh --help
```

**Phase 3: Testing & Validation**
```bash
# 1. Run comprehensive test suite
./test_runner.sh

# 2. Test specific functionality
./gitsim.sh init && ./gitsim.sh status

# 3. Validate template generation
./gitsim.sh template-list && ./gitsim.sh template rust test-project
```

**Phase 4: Documentation & Cleanup**
```bash
# 1. Update documentation
vim README.md SESSION.md

# 2. Clean test artifacts
./gitsim.sh cleanup --force

# 3. Commit changes (if using git)
git add parts/ build.sh && git commit -m "feat: add new feature"
```

üß™ TESTING FRAMEWORK WORKFLOW
==============================

**test_runner.sh Capabilities:**
- **Basic Command Tests**: --help, version, template-list validation
- **Workflow Tests**: Complete init -> add -> commit -> status cycles
- **Template Tests**: All 4 template types generation and validation
- **Home Environment Tests**: Simulated home directory operations
- **Cleanup Tests**: Artifact removal and system state restoration

**Testing Best Practices:**
```bash
# 1. Always run tests before committing
./test_runner.sh

# 2. Test individual components during development
./gitsim.sh template-show rust  # Preview without creation

# 3. Test in isolated directories
cd $(mktemp -d) && /path/to/gitsim.sh init

# 4. Validate cleanup
./gitsim.sh cleanup --force && ls -la  # Should be clean
```

üîç CRITICAL BASHFX 2.1 PATTERNS
================================

**üö® TEMPLATE FUNCTION RETURNS**
All template creation functions MUST end with explicit `return 0`:
```bash
# Issue: trace function returns exit code when opt_trace=false
some_template_function() {
    # ... template logic ...
    trace "Template created successfully"
    return 0  # CRITICAL: Always add this!
}
```

**üö® EXIT CODE PROPAGATION**
BashFX main pattern needs explicit exit handling:
```bash
main() {
    dispatch "$@"
    return $?  # CRITICAL: Propagate exit codes
}

# In part_99_main.sh:
ret=$?
exit $ret  # CRITICAL: Exit with proper code
```

**üö® HEREDOC SAFETY**
Always validate heredoc closure in template functions:
```bash
# Find all heredocs:
grep -n "cat.*<<.*EOF" parts/*.sh

# Verify each has corresponding EOF closure
# Unclosed heredocs silently break script loading!
```

**üö® ARGUMENT FILTERING**
Command-specific vs global flags require careful handling:
```bash
# Global flags: -d|--debug|-t|--trace|-q|--quiet|-y|--yes|-D|--dev|-h|--help
# Command flags: -m|--allow-empty|--template=*|--porcelain|--force
```

üõ°Ô∏è DEVELOPMENT SAFETY PATTERNS
===============================

**Build Validation Pipeline:**
```bash
# 1. Environment checks
[[ -d "parts" ]] || { echo "ERROR: No parts/ directory"; exit 1; }

# 2. Syntax validation
bash -n gitsim.sh || { echo "ERROR: Syntax error in build"; exit 1; }

# 3. Function validation
./gitsim.sh --help > /dev/null || { echo "ERROR: Help system broken"; exit 1; }

# 4. Test execution
./test_runner.sh || { echo "ERROR: Tests failed"; exit 1; }
```

**Session Management:**
- Keep SESSION.md current with findings and blocked items
- Document continuation priorities for future sessions
- Progressive validation: Phase 1 (build), Phase 2 (features), Phase 3 (core)
- Remove test artifacts between phases

üîß ADDING NEW FUNCTIONALITY
============================

**Step 1: Plan the Feature**
```bash
# 1. Determine the appropriate part number
ls parts/part_*.sh | sort -n

# 2. Choose category:
#    01-06: Infrastructure
#    13-17: Templates/Features
#    69-80: Command Dispatch
#    90-99: Main/Bootstrap
```

**Step 2: Implement the Feature**
```bash
# 1. Create new part file
vim parts/part_XX_my_feature.sh

# 2. Follow existing patterns:
#    - Function naming conventions
#    - Error handling patterns
#    - Help text formatting
#    - Return code handling
```

**Step 3: Integrate the Feature**
```bash
# 1. Add to build.map
echo "XX : part_XX_my_feature.sh" >> parts/build.map

# 2. Update command dispatcher (if adding commands)
vim parts/part_69_dispatcher.sh

# 3. Add help text (if user-facing)
vim parts/part_80_dispatchable_utils.sh
```

**Step 4: Build and Test**
```bash
# 1. Build project
./build.sh

# 2. Test new functionality
./gitsim.sh my-new-command

# 3. Run full test suite
./test_runner.sh

# 4. Update documentation
vim README.md
```

üöÄ DEBUGGING MULTI-PART SYSTEMS
================================

**Common Issues & Solutions:**

**1. Function Not Found Errors**
```bash
# Debug: Check if function exists
grep -n "function_name" parts/*.sh

# Debug: Check execution order
cat parts/build.map

# Solution: Ensure function defined before use
```

**2. Argument Parsing Issues**
```bash
# Debug: BashFX pattern for argument filtering
grep -n "orig_args" parts/*.sh

# Solution: Follow established arg parsing patterns
```

**3. Template Generation Failures**
```bash
# Debug: Check for unclosed heredocs
grep -n "cat.*<<.*EOF" parts/*.sh

# Debug: Verify return codes
grep -n "return" parts/part_1*_templates_*.sh
```

**4. Dispatcher Conflicts**
```bash
# Debug: Check for multiple dispatch() functions
grep -n "dispatch()" parts/*.sh

# Solution: Ensure only one primary dispatcher
```

üìä DEVELOPMENT METRICS & MONITORING
====================================

**Build System Health:**
- **Build Time**: Should be sub-second on modern systems
- **Script Size**: Monitor growth, warn at 4000+ lines (AI limit)
- **Part Count**: Currently 18 parts, plan for scalability
- **Test Coverage**: Aim for 100% command coverage

**Quality Indicators:**
- **Test Pass Rate**: ./test_runner.sh should always pass
- **Syntax Validation**: bash -n gitsim.sh should never fail
- **Help System**: All commands should have proper help text
- **Cleanup**: ./gitsim.sh cleanup --force should restore clean state

üéØ BEST PRACTICES CHECKLIST
============================

**Before Making Changes:**
‚úÖ Read CLAUDE.md for project-specific patterns
‚úÖ Check SESSION.md for previous work and issues
‚úÖ Understand current build.map structure
‚úÖ Run ./test_runner.sh to establish baseline

**During Development:**
‚úÖ Edit parts/ files, never gitsim.sh directly
‚úÖ Add `return 0` to all template functions
‚úÖ Validate heredoc closures
‚úÖ Follow existing naming conventions
‚úÖ Build and test frequently

**Before Committing:**
‚úÖ Run ./build.sh successfully
‚úÖ Pass ./test_runner.sh completely
‚úÖ Update documentation as needed
‚úÖ Clean test artifacts with cleanup command
‚úÖ Verify functionality with manual testing

üéâ KEY TAKEAWAYS
================
1. **MODULAR DEVELOPMENT**: Edit parts/, not the final script
2. **VALIDATION DRIVEN**: Test early, test often, test everything
3. **PATTERN COMPLIANCE**: Follow established BashFX 2.1 patterns
4. **COMPREHENSIVE TESTING**: Use test_runner.sh for quality assurance
5. **PROFESSIONAL WORKFLOW**: Document, build, test, integrate, deploy

üìö DEVELOPMENT REFERENCES
=========================
- **CLAUDE.md**: Critical patterns and insights from development
- **SESSION.md**: Previous work, blocked items, continuation notes
- **build.sh**: Build system implementation and validation
- **test_runner.sh**: Comprehensive testing framework
- **parts/build.map**: Component assembly specification
- **parts/part_*.sh**: Individual component implementations

‚ö†Ô∏è DISCLAIMER
==============
This development workflow guide reflects GitSim v2.0.0 BashFX 2.1 patterns
as analyzed on 2024-09-17. Development patterns and critical insights are
based on CLAUDE.md content and project structure analysis. Always refer to
current project documentation and established patterns when making changes.

üìã VALIDATION PERFORMED
========================
‚úÖ CLAUDE.md development patterns analyzed
‚úÖ test_runner.sh framework examined
‚úÖ Build system workflow documented
‚úÖ Critical BashFX 2.1 patterns identified
‚úÖ Development safety practices verified

================================================================================
 üêî CHINA'S CERTIFICATION: PROFESSIONAL DEVELOPMENT WORKFLOW!
 "This BashFX 2.1 workflow is absolutely egg-ceptional for maintainable bash!" ü•ö‚ú®
================================================================================