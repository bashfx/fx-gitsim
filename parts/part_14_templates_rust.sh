################################################################################
# Rust Template Module
################################################################################

# Register this template with the core system
_register_template "rust" "Rust project with Cargo" "rs"

################################################################################
# Rust Template Implementation
################################################################################

# Main creation function (standard interface)
_create_rust_template() {
    local target_dir="$1"
    local project_name="$2"
    
    # Create Rust project structure
    mkdir -p "$target_dir"/{src,tests,examples}
    
    # Generate all Rust project files
    __print_cargo_toml "$target_dir/Cargo.toml" "$project_name"
    __print_rust_main "$target_dir/src/main.rs" "$project_name"
    __print_rust_lib "$target_dir/src/lib.rs" "$project_name"
    __print_rust_integration_test "$target_dir/tests/integration_test.rs" "$project_name"
    __print_rust_example "$target_dir/examples/basic.rs" "$project_name"
    __print_rust_gitignore "$target_dir/.gitignore"
    __print_readme_md "$target_dir/README.md" "$project_name" "Rust"
    
    # Generate fake Cargo.lock for realism
    __print_cargo_lock "$target_dir/Cargo.lock" "$project_name"
    
    trace "Created Rust project structure in $target_dir"
    return 0
}

# Template preview function
_show_rust_template() {
    cat << 'EOF'
Rust project structure:
  Cargo.toml          - Package manifest with dependencies
  Cargo.lock          - Lock file for reproducible builds
  src/
    main.rs           - Binary entry point
    lib.rs            - Library root with basic functions
  tests/
    integration_test.rs - Integration tests
  examples/
    basic.rs          - Usage example
  .gitignore          - Rust-specific ignore patterns
  README.md           - Project documentation

Dependencies included: clap, serde, tokio (dev)
EOF
}

################################################################################
# Rust File Generators
################################################################################

__print_cargo_toml() {
    local file="$1"
    local name="$2"
    
    cat > "$file" << EOF
[package]
name = "$name"
version = "0.1.0"
edition = "2021"
authors = ["$SIM_USER <${SIM_USER}@example.com>"]
description = "A sample Rust project generated by GitSim"
license = "MIT OR Apache-2.0"
repository = "https://github.com/${SIM_USER}/${name}"
keywords = ["cli", "sample", "gitsim"]
categories = ["command-line-utilities"]

[dependencies]
clap = { version = "4.4", features = ["derive"] }
serde = { version = "1.0", features = ["derive"] }
tokio = { version = "1.0", features = ["rt-multi-thread", "macros"] }

[dev-dependencies]
tokio-test = "0.4"

[[bin]]
name = "$name"
path = "src/main.rs"

[[example]]
name = "basic"
path = "examples/basic.rs"

[profile.release]
opt-level = 3
lto = true
codegen-units = 1
panic = "abort"
EOF
}

__print_rust_main() {
    local file="$1"
    local name="$2"
    
    cat > "$file" << EOF
use clap::{Arg, Command};
use std::process;

fn main() {
    let matches = Command::new("$name")
        .version("0.1.0")
        .author("$SIM_USER <${SIM_USER}@example.com>")
        .about("A sample Rust application generated by GitSim")
        .arg(
            Arg::new("name")
                .short('n')
                .long("name")
                .value_name("NAME")
                .help("Name to greet")
                .default_value("World"),
        )
        .arg(
            Arg::new("count")
                .short('c')
                .long("count")
                .value_name("COUNT")
                .help("Number of times to greet")
                .value_parser(clap::value_parser!(u32))
                .default_value("1"),
        )
        .get_matches();

    let name = matches.get_one::<String>("name").unwrap();
    let count = matches.get_one::<u32>("count").unwrap();

    for i in 1..=*count {
        if *count > 1 {
            println!("{}: Hello, {} from $name!", i, name);
        } else {
            println!("Hello, {} from $name!", name);
        }
    }

    // Demonstrate library usage
    let greeting = ${name//-/_}::create_greeting(name);
    println!("Library says: {}", greeting);

    let sum = ${name//-/_}::add(10, 15);
    println!("10 + 15 = {}", sum);

    println!("\\n$name completed successfully!");
}
EOF
}

__print_rust_lib() {
    local file="$1"
    local name="$2"
    local lib_name="${name//-/_}"  # Convert hyphens to underscores for valid Rust identifiers
    
    cat > "$file" << EOF
//! $name library
//!
//! This is a sample library generated by GitSim for testing purposes.
//! It provides basic functionality for greeting users and performing calculations.

use serde::{Deserialize, Serialize};

/// Configuration struct for the application
#[derive(Debug, Serialize, Deserialize)]
pub struct Config {
    pub default_name: String,
    pub max_count: u32,
}

impl Default for Config {
    fn default() -> Self {
        Self {
            default_name: "World".to_string(),
            max_count: 100,
        }
    }
}

/// Creates a greeting message for the given name
///
/// # Arguments
///
/// * \`name\` - The name to include in the greeting
///
/// # Examples
///
/// \`\`\`
/// use $lib_name::create_greeting;
///
/// let greeting = create_greeting("Alice");
/// assert_eq!(greeting, "Greetings, Alice! Welcome to $name.");
/// \`\`\`
pub fn create_greeting(name: &str) -> String {
    format!("Greetings, {}! Welcome to $name.", name)
}

/// Adds two numbers together
///
/// This is a simple utility function for demonstration purposes.
///
/// # Arguments
///
/// * \`left\` - The first number
/// * \`right\` - The second number
///
/// # Examples
///
/// \`\`\`
/// use $lib_name::add;
///
/// let result = add(2, 3);
/// assert_eq!(result, 5);
/// \`\`\`
pub fn add(left: usize, right: usize) -> usize {
    left + right
}

/// Multiplies two numbers
pub fn multiply(a: i32, b: i32) -> i32 {
    a * b
}

/// Validates that a count is within acceptable limits
pub fn validate_count(count: u32, config: &Config) -> Result<(), String> {
    if count > config.max_count {
        Err(format!("Count {} exceeds maximum of {}", count, config.max_count))
    } else {
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_create_greeting() {
        let result = create_greeting("Test");
        assert_eq!(result, "Greetings, Test! Welcome to $name.");
    }

    #[test]
    fn test_add() {
        assert_eq!(add(2, 3), 5);
        assert_eq!(add(0, 0), 0);
        assert_eq!(add(100, 200), 300);
    }

    #[test]
    fn test_multiply() {
        assert_eq!(multiply(4, 5), 20);
        assert_eq!(multiply(-2, 3), -6);
        assert_eq!(multiply(0, 100), 0);
    }

    #[test]
    fn test_validate_count() {
        let config = Config::default();
        
        assert!(validate_count(50, &config).is_ok());
        assert!(validate_count(100, &config).is_ok());
        assert!(validate_count(101, &config).is_err());
    }

    #[test]
    fn test_config_default() {
        let config = Config::default();
        assert_eq!(config.default_name, "World");
        assert_eq!(config.max_count, 100);
    }
}
EOF
}

__print_rust_integration_test() {
    local file="$1"
    local name="$2"
    local lib_name="${name//-/_}"
    
    cat > "$file" << EOF
//! Integration tests for $name
//!
//! These tests verify that the library components work together correctly.

use $lib_name::{create_greeting, add, multiply, validate_count, Config};

#[test]
fn integration_test_greeting_workflow() {
    // Test the complete greeting workflow
    let name = "Integration Test";
    let greeting = create_greeting(name);
    
    assert!(greeting.contains(name));
    assert!(greeting.contains("$name"));
}

#[test]
fn integration_test_math_operations() {
    // Test mathematical operations work together
    let a = 10;
    let b = 5;
    
    let sum = add(a, b);
    let product = multiply(a as i32, b as i32);
    
    assert_eq!(sum, 15);
    assert_eq!(product, 50);
    
    // Test chaining operations
    let result = add(sum, product as usize);
    assert_eq!(result, 65);
}

#[test]
fn integration_test_config_validation() {
    // Test configuration and validation integration
    let config = Config {
        default_name: "TestUser".to_string(),
        max_count: 10,
    };
    
    // Valid count should pass
    assert!(validate_count(5, &config).is_ok());
    
    // Invalid count should fail
    assert!(validate_count(15, &config).is_err());
}

#[tokio::test]
async fn integration_test_async_operations() {
    // Test async functionality (using tokio for realistic project structure)
    let result = async_greeting("Async Test").await;
    assert!(result.contains("Async Test"));
}

// Helper async function for testing
async fn async_greeting(name: &str) -> String {
    tokio::time::sleep(tokio::time::Duration::from_millis(1)).await;
    create_greeting(name)
}
EOF
}

__print_rust_example() {
    local file="$1"
    local name="$2"
    local lib_name="${name//-/_}"
    
    cat > "$file" << EOF
//! Basic usage example for $name
//!
//! This example demonstrates how to use the $name library
//! in your own applications.

use $lib_name::{create_greeting, add, Config, validate_count};

fn main() {
    println!("=== $name Library Example ===\\n");
    
    // Example 1: Basic greeting
    println!("1. Basic greeting:");
    let greeting = create_greeting("Example User");
    println!("   {}", greeting);
    
    // Example 2: Math operations
    println!("\\n2. Math operations:");
    let sum = add(42, 8);
    println!("   42 + 8 = {}", sum);
    
    // Example 3: Configuration and validation
    println!("\\n3. Configuration and validation:");
    let config = Config {
        default_name: "Default User".to_string(),
        max_count: 50,
    };
    
    println!("   Config: default_name='{}', max_count={}", 
             config.default_name, config.max_count);
    
    // Test validation
    match validate_count(25, &config) {
        Ok(_) => println!("   Count 25 is valid"),
        Err(e) => println!("   Error: {}", e),
    }
    
    match validate_count(75, &config) {
        Ok(_) => println!("   Count 75 is valid"),
        Err(e) => println!("   Error: {}", e),
    }
    
    println!("\\n=== Example completed ===");
}
EOF
}

__print_rust_gitignore() {
    local file="$1"
    
    cat > "$file" << 'EOF'
# Rust
/target/
**/*.rs.bk
*.pdb

# Cargo
Cargo.lock

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db

# Local development
.env
*.log
EOF
    
    # Add common patterns
    __print_common_gitignore "$file"
}

__print_cargo_lock() {
    local file="$1"
    local name="$2"
    
    cat > "$file" << EOF
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 3

[[package]]
name = "$name"
version = "0.1.0"
dependencies = [
 "clap",
 "serde",
 "tokio",
]

[[package]]
name = "clap"
version = "4.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fake-checksum-for-gitsim-testing"

[[package]]  
name = "serde"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fake-checksum-for-gitsim-testing"

[[package]]
name = "tokio"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index" 
checksum = "fake-checksum-for-gitsim-testing"
EOF
}