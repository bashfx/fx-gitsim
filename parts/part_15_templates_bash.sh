################################################################################
# BashFX Template Module
################################################################################

# Register this template with the core system
_register_template "bash" "BashFX-compliant script project" "sh bashfx"

################################################################################
# BashFX Template Implementation
################################################################################

# Main creation function (standard interface)
_create_bash_template() {
    local target_dir="$1"
    local project_name="$2"
    local testsh_flag="${3:-false}"

    # Create BashFX project structure
    if [[ "$testsh_flag" == true ]]; then
        # Enhanced structure with TESTSH
        mkdir -p "$target_dir"/{parts,tests/{unit,sanity,smoke,integration,e2e,uat,chaos,bench,_adhoc},scripts}
    else
        # Standard structure
        mkdir -p "$target_dir"/{parts,tests}
    fi

    # Generate BashFX project files
    __print_bashfx_script "$target_dir/${project_name}.sh" "$project_name"
    __print_bashfx_buildmap "$target_dir/parts/build.map"
    __print_bashfx_header "$target_dir/parts/01_header.sh" "$project_name"
    __print_bashfx_main "$target_dir/parts/02_main.sh" "$project_name"
    __print_bashfx_build_script "$target_dir/build.sh" "$project_name"

    # Choose test runner based on testsh flag
    if [[ "$testsh_flag" == true ]]; then
        __print_testsh_bash_runner "$target_dir/test.sh" "$project_name"
        __print_testsh_bootstrap_bash "$target_dir/scripts/bootstrap-tests.sh" "$project_name"
        __print_testsh_bash_examples "$target_dir" "$project_name"
        __print_testsh_gitignore "$target_dir/.gitignore"
    else
        __print_bash_test_runner "$target_dir/test_runner.sh" "$project_name"
        __print_bash_gitignore "$target_dir/.gitignore"
    fi

    __print_readme_md "$target_dir/README.md" "$project_name" "BashFX"

    # Make scripts executable
    chmod +x "$target_dir/${project_name}.sh"
    chmod +x "$target_dir/build.sh"

    if [[ "$testsh_flag" == true ]]; then
        chmod +x "$target_dir/test.sh"
        chmod +x "$target_dir/scripts/bootstrap-tests.sh"
        chmod +x "$target_dir/tests/_adhoc"/*.sh 2>/dev/null || true
    else
        chmod +x "$target_dir/test_runner.sh"
    fi

    trace "Created BashFX project structure in $target_dir"
    if [[ "$testsh_flag" == true ]]; then
        trace "Included TESTSH comprehensive test suite"
    fi
    return 0
}

# Template preview function
_show_bash_template() {
    cat << 'EOF'
BashFX project structure:
  project.sh          - Main BashFX-compliant script
  build.sh            - Modular build system
  parts/
    build.map         - Build configuration
    01_header.sh      - Script header with metadata
    02_main.sh        - Main function and execution
  tests/
  test_runner.sh      - Test framework
  .gitignore          - Bash-specific ignore patterns  
  README.md           - Project documentation

Features: Full BashFX 2.0 compliance, modular build system, proper function ordinality
EOF
}

################################################################################
# BashFX File Generators
################################################################################

__print_bashfx_script() {
    local file="$1"
    local name="$2"
    
    cat > "$file" << EOF
#!/usr/bin/env bash
#
# $name - BashFX-Compliant Script
#
# name: $name
# version: 1.0.0
# desc: Sample BashFX-compliant script generated by GitSim
# author: $SIM_USER
#
# portable: grep, sed, awk, find
# builtins: printf, read, local, declare, case, if, for, while, shift, return

################################################################################
# Configuration & Standards
################################################################################

readonly SCRIPT_NAME="$name"
readonly SCRIPT_VERSION="1.0.0"

# XDG+ Configuration
: \${XDG_HOME:="\$HOME/.local"}
: \${XDG_DATA_HOME:="\$XDG_HOME/data"}
: \${XDG_CONFIG_HOME:="\$HOME/.config"}

# Standard option flags
opt_debug=false
opt_trace=false
opt_quiet=false
opt_force=false
opt_yes=false

################################################################################
# stderr functions
################################################################################

stderr() { printf "%s\\n" "\$*" >&2; }
info() { [[ "\$opt_quiet" == true ]] && return; stderr "[INFO] \$*"; }
warn() { [[ "\$opt_quiet" == true ]] && return; stderr "[WARN] \$*"; }
error() { stderr "[ERROR] \$*"; }
fatal() { stderr "[FATAL] \$*"; exit 1; }
okay() { [[ "\$opt_quiet" == true ]] && return; stderr "[OK] \$*"; }
trace() { [[ "\$opt_trace" == true ]] && stderr "[TRACE] \$*"; }

################################################################################
# Helper Functions
################################################################################

_logo() {
    cat << 'LOGO_EOF'
 _____ _____ _____ _____ 
|   __|     | __  |     |
|__   |   --|    -|-   -|
|_____|_____|__|__|_____|
$name v$SCRIPT_VERSION
LOGO_EOF
}

_validate_input() {
    local input="\$1"
    
    if [[ -z "\$input" ]]; then
        error "Input required"
        return 1
    fi
    
    return 0
}

################################################################################
# Dispatchable Functions (High-Order)
################################################################################

do_hello() {
    local name="\${1:-World}"
    
    if ! _validate_input "\$name"; then
        return 1
    fi
    
    okay "Hello, \$name from \$SCRIPT_NAME!"
    trace "Greeting completed for: \$name"
    return 0
}

do_demo() {
    info "Running \$SCRIPT_NAME demonstration"
    
    _logo
    
    printf "\\nThis is a BashFX-compliant script with:\\n"
    printf "- Proper function ordinality\\n"
    printf "- XDG+ directory compliance\\n"
    printf "- Standard option parsing\\n"
    printf "- Modular build system support\\n"
    printf "- Comprehensive error handling\\n"
    
    okay "Demo completed successfully"
    return 0
}

do_status() {
    printf "Script: %s\\n" "\$SCRIPT_NAME"
    printf "Version: %s\\n" "\$SCRIPT_VERSION"
    printf "Author: %s\\n" "$SIM_USER"
    printf "Debug: %s\\n" "\$opt_debug"
    printf "Quiet: %s\\n" "\$opt_quiet"
    printf "XDG_HOME: %s\\n" "\$XDG_HOME"
    return 0
}

do_version() {
    printf "%s v%s\\n" "\$SCRIPT_NAME" "\$SCRIPT_VERSION"
    return 0
}

################################################################################
# Core System Functions  
################################################################################

dispatch() {
    local cmd="\$1"
    shift
    
    case "\$cmd" in
        hello)   do_hello "\$@";;
        demo)    do_demo "\$@";;
        status)  do_status "\$@";;
        version) do_version "\$@";;
        *)
            error "Unknown command: \$cmd"
            usage
            return 1
            ;;
    esac
}

usage() {
    cat << 'USAGE_EOF'
$name - BashFX-Compliant Script

USAGE:
    $name <command> [options] [args]

COMMANDS:
    hello [name]        Greet someone (default: World)
    demo               Run demonstration
    status             Show script status
    version            Show version information

OPTIONS:
    -d, --debug        Enable debug output
    -t, --trace        Enable trace output (implies -d)
    -q, --quiet        Suppress all output except errors
    -f, --force        Force operations, bypass safety checks
    -y, --yes          Automatically answer yes to prompts

EXAMPLES:
    $name hello Alice
    $name demo
    $name status
    
This script follows BashFX 2.0 architecture standards.
    
USAGE_EOF
}

options() {
    local this next opts=("\$@")
    for ((i=0; i<\${#opts[@]}; i++)); do
        this=\${opts[i]}
        next=\${opts[i+1]}
        case "\$this" in
            -d|--debug)
                opt_debug=true
                ;;
            -t|--trace)
                opt_trace=true
                opt_debug=true
                ;;
            -q|--quiet)
                opt_quiet=true
                ;;
            -f|--force)
                opt_force=true
                ;;
            -y|--yes)
                opt_yes=true
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            *)
                :
                ;;
        esac
    done
}

main() {
    # Show logo unless quiet
    if [[ "\$opt_quiet" != true ]]; then
        _logo
        printf "\\n"
    fi
    
    # Show help if no command provided
    if [[ \${#@} -eq 0 ]]; then
        usage
        exit 0
    fi
    
    # Dispatch to command
    dispatch "\$@"
}

# Script execution using BashFX pattern
if [ "\$0" = "-bash" ]; then
    :
else
    # direct call
    orig_args=("\$@")
    options "\${orig_args[@]}"
    args=("\${orig_args[@]##-*}") # delete anything that looks like an option
    main "\${args[@]}"
    ret=\$?
fi
EOF
}

__print_bashfx_buildmap() {
    local file="$1"
    
    cat > "$file" << 'EOF'
# Build Map for BashFX Project
# Format: NN : target_filename.sh
# Lines starting with # are ignored
# Place this file in: parts/build.map

01 : 01_header.sh
02 : 02_main.sh
EOF
}

__print_bashfx_header() {
    local file="$1"
    local name="$2"
    
    cat > "$file" << EOF
#!/usr/bin/env bash
#
# $name - BashFX-Compliant Script
#
# name: $name
# version: 1.0.0
# desc: Sample BashFX-compliant script generated by GitSim
# author: $SIM_USER
#
# portable: grep, sed, awk, find
# builtins: printf, read, local, declare, case, if, for, while, shift, return
EOF
}

__print_bashfx_main() {
    local file="$1"
    local name="$2"
    
    cat > "$file" << EOF
main() {
    # Show logo unless quiet
    if [[ "\$opt_quiet" != true ]]; then
        _logo
        printf "\\n"
    fi
    
    # Show help if no command provided
    if [[ \${#@} -eq 0 ]]; then
        usage
        exit 0
    fi
    
    # Dispatch to command
    dispatch "\$@"
}

# Script execution using BashFX pattern
if [ "\$0" = "-bash" ]; then
    :
else
    # direct call
    orig_args=("\$@")
    options "\${orig_args[@]}"
    args=("\${orig_args[@]##-*}") # delete anything that looks like an option
    main "\${args[@]}"
    ret=\$?
fi
EOF
}

__print_bashfx_build_script() {
    local file="$1"
    local name="$2"
    
    cat > "$file" << EOF
#!/usr/bin/env bash
#
# build.sh - BashFX Build Script for $name
#

# Configuration
OUTPUT_FILE="$name.sh"
PARTS_DIR="parts"
BUILD_MAP="\$PARTS_DIR/build.map"
BACKUP_SUFFIX=".bak"

# Colors for output
readonly RED=\$'\\033[31m'
readonly GREEN=\$'\\033[32m' 
readonly YELLOW=\$'\\033[33m'
readonly BLUE=\$'\\033[34m'
readonly RESET=\$'\\033[0m'

# Logging functions
info() { printf "%s[INFO]%s %s\\n" "\$BLUE" "\$RESET" "\$*" >&2; }
okay() { printf "%s[OK]%s %s\\n" "\$GREEN" "\$RESET" "\$*" >&2; }
warn() { printf "%s[WARN]%s %s\\n" "\$YELLOW" "\$RESET" "\$*" >&2; }
error() { printf "%s[ERROR]%s %s\\n" "\$RED" "\$RESET" "\$*" >&2; }
fatal() { error "\$*"; exit 1; }

# Validate build environment
check_environment() {
    [[ -d "\$PARTS_DIR" ]] || fatal "Parts directory '\$PARTS_DIR' not found"
    [[ -f "\$BUILD_MAP" ]] || fatal "Build map '\$BUILD_MAP' not found"
    info "Environment validated"
}

# Build the output file from parts
build_script() {
    local temp_file="\${OUTPUT_FILE}.tmp"
    local parts_used=0
    
    info "Building \$OUTPUT_FILE from parts..."
    
    # Create temporary file
    > "\$temp_file"
    
    # Process build map
    while IFS= read -r line; do
        # Skip comments and empty lines
        [[ "\$line" =~ ^\[[:space:\]\]*# ]] && continue
        [[ -z "\${line// }" ]] && continue
        
        # Parse map entry: "NN : filename.sh"
        if [[ "\$line" =~ ^([0-9]+)[[:space:]]*:[[:space:]]*(.+)\$ ]]; then
            local part_num="\${BASH_REMATCH[1]}"
            local part_file="\${BASH_REMATCH[2]// /}" # Remove spaces
            local part_path="\$PARTS_DIR/\$part_file"
            
            if [[ -f "\$part_path" ]]; then
                info "Adding part \$part_num: \$part_file"
                cat "\$part_path" >> "\$temp_file"
                echo >> "\$temp_file"  # Add newline between parts
                ((parts_used++))
            else
                warn "Part file not found: \$part_path"
            fi
        fi
    done < "\$BUILD_MAP"
    
    if [[ \$parts_used -eq 0 ]]; then
        fatal "No parts were processed"
    fi
    
    # Backup existing file if it exists
    if [[ -f "\$OUTPUT_FILE" ]]; then
        cp "\$OUTPUT_FILE" "\${OUTPUT_FILE}\${BACKUP_SUFFIX}"
        info "Backed up existing file to \${OUTPUT_FILE}\${BACKUP_SUFFIX}"
    fi
    
    # Move temp file to final location
    mv "\$temp_file" "\$OUTPUT_FILE"
    chmod +x "\$OUTPUT_FILE"
    
    okay "Built \$OUTPUT_FILE from \$parts_used parts"
}

# Main execution
main() {
    case "\${1:-build}" in
        build)
            check_environment
            build_script
            ;;
        clean)
            rm -f "\${OUTPUT_FILE}.tmp" "\${OUTPUT_FILE}\${BACKUP_SUFFIX}"
            okay "Cleaned build artifacts"
            ;;
        *)
            echo "Usage: \$0 [build|clean]"
            exit 1
            ;;
    esac
}

main "\$@"
EOF
}

__print_bash_test_runner() {
    local file="$1"
    local name="$2"
    
    cat > "$file" << EOF
#!/usr/bin/env bash
# test_runner.sh - Test Framework for $name

set -e

# Test configuration
readonly TEST_SCRIPT="./$name.sh"
readonly RED=\$'\\033[31m'
readonly GREEN=\$'\\033[32m'
readonly RESET=\$'\\033[0m'

# Test counters
TESTS_RUN=0
TESTS_PASSED=0
TESTS_FAILED=0

echo "=== Running Tests for $name ==="
echo

# Test framework functions
test_start() {
    local description="\$1"
    printf "Testing: %s ... " "\$description"
    ((TESTS_RUN++))
}

test_pass() {
    printf "%s✓ PASS%s\\n" "\$GREEN" "\$RESET"
    ((TESTS_PASSED++))
}

test_fail() {
    local message="\$1"
    printf "%s✗ FAIL%s" "\$RED" "\$RESET"
    [[ -n "\$message" ]] && printf " - %s" "\$message"
    printf "\\n"
    ((TESTS_FAILED++))
}

# Individual test functions
test_version() {
    test_start "version command"
    local output
    if output=\$("\$TEST_SCRIPT" version 2>&1); then
        if [[ "\$output" == *"$name v1.0.0"* ]]; then
            test_pass
        else
            test_fail "Expected version string not found"
        fi
    else
        test_fail "Command failed"
    fi
}

test_hello() {
    test_start "hello command"
    local output
    if output=\$("\$TEST_SCRIPT" hello Alice 2>&1); then
        if [[ "\$output" == *"Hello, Alice"* ]]; then
            test_pass
        else
            test_fail "Expected greeting not found"
        fi
    else
        test_fail "Command failed"
    fi
}

test_demo() {
    test_start "demo command"
    local output
    if output=\$("\$TEST_SCRIPT" demo 2>&1); then
        if [[ "\$output" == *"demonstration"* ]]; then
            test_pass
        else
            test_fail "Demo output not as expected"
        fi
    else
        test_fail "Command failed"
    fi
}

test_status() {
    test_start "status command"
    local output
    if output=\$("\$TEST_SCRIPT" status 2>&1); then
        if [[ "\$output" == *"Script: $name"* ]]; then
            test_pass
        else
            test_fail "Status output not as expected"
        fi
    else
        test_fail "Command failed"
    fi
}

test_invalid_command() {
    test_start "invalid command handling"
    local output
    if output=\$("\$TEST_SCRIPT" invalid_command 2>&1); then
        # Should fail (return non-zero)
        test_fail "Command should have failed"
    else
        if [[ "\$output" == *"Unknown command"* ]]; then
            test_pass
        else
            test_fail "Expected error message not found"
        fi
    fi
}

test_help() {
    test_start "help output"
    local output
    if output=\$("\$TEST_SCRIPT" --help 2>&1); then
        if [[ "\$output" == *"USAGE:"* ]] && [[ "\$output" == *"COMMANDS:"* ]]; then
            test_pass
        else
            test_fail "Help format not as expected"
        fi
    else
        test_fail "Help command failed"
    fi
}

# Run all tests
run_tests() {
    # Check if script exists
    if [[ ! -f "\$TEST_SCRIPT" ]]; then
        echo "Error: Test script \$TEST_SCRIPT not found"
        echo "Run 'build.sh' first to create the script"
        exit 1
    fi
    
    # Run individual tests
    test_version
    test_hello
    test_demo
    test_status
    test_invalid_command
    test_help
}

# Show results
show_results() {
    echo
    echo "=== Test Results ==="
    printf "Tests run: %d\\n" "\$TESTS_RUN"
    printf "%sPassed: %d%s\\n" "\$GREEN" "\$TESTS_PASSED" "\$RESET"
    
    if [[ \$TESTS_FAILED -gt 0 ]]; then
        printf "%sFailed: %d%s\\n" "\$RED" "\$TESTS_FAILED" "\$RESET"
        echo
        echo "❌ Some tests failed"
        exit 1
    else
        echo
        echo "✅ All tests passed!"
    fi
}

# Main execution
main() {
    run_tests
    show_results
}

main "\$@"
EOF
}

__print_bash_gitignore() {
    local file="$1"
    
    cat > "$file" << 'EOF'
# Build artifacts
*.tmp
*.bak
build/
dist/

# BashFX build system
parts/*.tmp
EOF
    
    # Add common patterns
    __print_common_gitignore "$file"
}

################################################################################
# TESTSH Integration Functions for Bash Template
################################################################################

__print_testsh_bash_runner() {
    local file="$1"
    local name="$2"

    cat > "$file" << EOF
#!/usr/bin/env bash
# test.sh - TESTSH-Compliant Test Runner for $name (BashFX integration)
#
# Supports hierarchical test execution with BashFX project structure

set -e

# Configuration
readonly SCRIPT_NAME="test.sh"
readonly SCRIPT_VERSION="1.0.0"
readonly PROJECT_NAME="$name"
readonly PROJECT_SCRIPT="./$name.sh"

# Colors for output
readonly RED=\$'\\033[31m'
readonly GREEN=\$'\\033[32m'
readonly YELLOW=\$'\\033[33m'
readonly BLUE=\$'\\033[34m'
readonly RESET=\$'\\033[0m'

# Test categories in execution order
readonly TEST_CATEGORIES=(
    "sanity"
    "smoke"
    "unit"
    "integration"
    "e2e"
    "uat"
    "chaos"
    "bench"
)

# Logging functions
info() { printf "%s[INFO]%s %s\\n" "\$BLUE" "\$RESET" "\$*" >&2; }
okay() { printf "%s[OK]%s %s\\n" "\$GREEN" "\$RESET" "\$*" >&2; }
warn() { printf "%s[WARN]%s %s\\n" "\$YELLOW" "\$RESET" "\$*" >&2; }
error() { printf "%s[ERROR]%s %s\\n" "\$RED" "\$RESET" "\$*" >&2; }

# BashFX integration - ensure project is built
ensure_project_built() {
    if [[ -f "build.sh" ]] && [[ ! -f "\$PROJECT_SCRIPT" || "build.sh" -nt "\$PROJECT_SCRIPT" ]]; then
        info "Building project before running tests..."
        bash build.sh build
    fi
}

# Test execution functions
run_category_tests() {
    local category="\$1"
    local test_dir="tests/\$category"
    local tests_found=0
    local tests_passed=0

    info "Running \$category tests..."

    # Run bash test files in category directory
    if [[ -d "\$test_dir" ]]; then
        for test_file in "\$test_dir"/*.sh; do
            [[ -f "\$test_file" ]] || continue
            [[ -x "\$test_file" ]] || continue

            info "Executing: \$(basename "\$test_file")"
            if bash "\$test_file"; then
                (( tests_passed++ ))
            fi
            (( tests_found++ ))
        done
    fi

    # Check for category wrapper script
    if [[ -f "tests/\$category.sh" ]]; then
        info "Executing category wrapper: \$category.sh"
        if bash "tests/\$category.sh"; then
            (( tests_passed++ ))
        fi
        (( tests_found++ ))
    fi

    if [[ \$tests_found -eq 0 ]]; then
        warn "No tests found for category: \$category"
    else
        okay "\$category: \$tests_passed/\$tests_found tests passed"
    fi

    return \$(( tests_found - tests_passed ))
}

run_adhoc_tests() {
    local adhoc_dir="tests/_adhoc"
    local tests_found=0
    local tests_passed=0

    info "Running adhoc tests..."

    if [[ -d "\$adhoc_dir" ]]; then
        for test_file in "\$adhoc_dir"/*; do
            [[ -f "\$test_file" ]] || continue
            [[ -x "\$test_file" ]] || continue

            info "Executing adhoc: \$(basename "\$test_file")"
            if "\$test_file"; then
                (( tests_passed++ ))
            fi
            (( tests_found++ ))
        done
    fi

    if [[ \$tests_found -eq 0 ]]; then
        warn "No adhoc tests found"
    else
        okay "adhoc: \$tests_passed/\$tests_found tests passed"
    fi

    return \$(( tests_found - tests_passed ))
}

# Command implementations
cmd_list() {
    info "Available test categories for \$PROJECT_NAME:"
    for category in "\${TEST_CATEGORIES[@]}"; do
        local count=0
        local wrapper_exists=false

        # Check for category wrapper
        [[ -f "tests/\$category.sh" ]] && wrapper_exists=true

        # Count individual test files
        if [[ -d "tests/\$category" ]]; then
            count=\$(find "tests/\$category" -name "*.sh" -type f | wc -l)
        fi

        printf "  %-12s" "\$category"
        [[ "\$wrapper_exists" == true ]] && printf "[wrapper] "
        printf "(%d files)\\n" "\$count"
    done

    # Count adhoc tests
    local adhoc_count=0
    if [[ -d "tests/_adhoc" ]]; then
        adhoc_count=\$(find "tests/_adhoc" -type f -executable | wc -l)
    fi
    printf "  %-12s(%d files)\\n" "_adhoc" "\$adhoc_count"
}

cmd_run() {
    local category="\$1"

    # Ensure project is built before testing
    ensure_project_built

    if [[ -z "\$category" ]]; then
        # Run all categories
        local total_failures=0

        info "Running all test categories for \$PROJECT_NAME"

        for cat in "\${TEST_CATEGORIES[@]}"; do
            run_category_tests "\$cat" || (( total_failures++ ))
        done

        # Run adhoc tests
        run_adhoc_tests || (( total_failures++ ))

        if [[ \$total_failures -eq 0 ]]; then
            okay "All test categories passed!"
        else
            error "\$total_failures test categories had failures"
            return 1
        fi
    else
        # Run specific category
        if [[ " \${TEST_CATEGORIES[*]} " =~ " \$category " ]]; then
            run_category_tests "\$category"
        elif [[ "\$category" == "adhoc" ]]; then
            run_adhoc_tests
        else
            error "Unknown test category: \$category"
            info "Available categories: \${TEST_CATEGORIES[*]} adhoc"
            return 1
        fi
    fi
}

cmd_bootstrap() {
    if [[ -f "scripts/bootstrap-tests.sh" ]]; then
        info "Running test structure bootstrap..."
        bash scripts/bootstrap-tests.sh "bash"
    else
        error "Bootstrap script not found: scripts/bootstrap-tests.sh"
        return 1
    fi
}

cmd_build() {
    if [[ -f "build.sh" ]]; then
        info "Building project..."
        bash build.sh build
    else
        error "Build script not found: build.sh"
        return 1
    fi
}

cmd_clean() {
    info "Cleaning test and build artifacts..."

    # Clean test artifacts
    find tests/ -name "*.tmp" -delete 2>/dev/null || true

    # Clean build artifacts if build.sh exists
    if [[ -f "build.sh" ]]; then
        bash build.sh clean 2>/dev/null || true
    fi

    okay "Artifacts cleaned"
}

# Usage information
usage() {
    cat << USAGE_EOF
\$SCRIPT_NAME v\$SCRIPT_VERSION - TESTSH Test Runner for \$PROJECT_NAME

USAGE:
    \$SCRIPT_NAME <command> [args]

COMMANDS:
    list                   List all test categories and counts
    run [category]         Run tests (all categories if none specified)
    bootstrap              Initialize TESTSH test structure for bash
    build                  Build the project using build.sh
    clean                  Clean test and build artifacts

TEST CATEGORIES:
    sanity, smoke, unit, integration, e2e, uat, chaos, bench, adhoc

EXAMPLES:
    \$SCRIPT_NAME list
    \$SCRIPT_NAME run
    \$SCRIPT_NAME run sanity
    \$SCRIPT_NAME bootstrap
    \$SCRIPT_NAME build
    \$SCRIPT_NAME clean

BASHFX INTEGRATION:
    - Automatically builds project before testing if needed
    - Supports modular build system via build.sh
    - Compatible with BashFX project structure

USAGE_EOF
}

# Main execution
main() {
    case "\${1:-run}" in
        list|ls)
            cmd_list
            ;;
        run|test)
            shift
            cmd_run "\$@"
            ;;
        bootstrap|init)
            cmd_bootstrap
            ;;
        build)
            cmd_build
            ;;
        clean)
            cmd_clean
            ;;
        help|--help|-h)
            usage
            ;;
        *)
            error "Unknown command: \$1"
            usage
            return 1
            ;;
    esac
}

main "\$@"
EOF
}

__print_testsh_bootstrap_bash() {
    local file="$1"
    local name="$2"

    cat > "$file" << EOF
#!/usr/bin/env bash
# scripts/bootstrap-tests.sh - TESTSH Structure Generator for $name
# Generates bash-specific test structure for BashFX projects

set -euo pipefail

# Colors for output
readonly GREEN=\$'\\033[32m'
readonly BLUE=\$'\\033[34m'
readonly RESET=\$'\\033[0m'

info() { printf "%s[INFO]%s %s\\n" "\$BLUE" "\$RESET" "\$*"; }
okay() { printf "%s[OK]%s %s\\n" "\$GREEN" "\$RESET" "\$*"; }

cat_wrapper() {
    local name="\$1"

    cat > "tests/\${name}.sh" <<BASH_EOF
#!/usr/bin/env bash
# tests/\${name}.sh - \${name} test wrapper for $name

# Source the main script for testing (after building)
if [[ -f "./$name.sh" ]]; then
    # Test by executing commands rather than sourcing
    TEST_SCRIPT="./$name.sh"
else
    echo "Error: Project script not found. Run 'bash build.sh' first."
    exit 1
fi

echo "Running \${name} tests for $name"

# Add your \${name} test logic here
# Example: \\\$TEST_SCRIPT version

exit 0
BASH_EOF
    chmod +x "tests/\${name}.sh"
}

main() {
    info "Bootstrapping TESTSH structure for bash project: $name"

    # Ensure test directories exist
    mkdir -p tests/{unit,sanity,smoke,integration,e2e,uat,chaos,bench,_adhoc}

    # Create top-level test wrappers
    info "Creating top-level test wrappers..."
    cat_wrapper "sanity"
    cat_wrapper "smoke"
    cat_wrapper "unit"
    cat_wrapper "integration"
    cat_wrapper "e2e"
    cat_wrapper "uat"
    cat_wrapper "chaos"
    cat_wrapper "bench"

    # Create category examples
    info "Creating category examples..."
    cat > tests/sanity/basic.sh <<'BASH_EOF'
#!/usr/bin/env bash
# tests/sanity/basic.sh - Basic sanity checks

# Project structure checks
test_project_structure() {
    [[ -f "build.sh" ]] || { echo "build.sh missing"; return 1; }
    [[ -f "parts/build.map" ]] || { echo "parts/build.map missing"; return 1; }
    [[ -d "parts" ]] || { echo "parts directory missing"; return 1; }
    echo "Project structure is sane"
    return 0
}

# Build system check
test_build_system() {
    if ! bash build.sh build; then
        echo "Build system failed"
        return 1
    fi
    echo "Build system is working"
    return 0
}

# Run tests
test_project_structure
test_build_system
BASH_EOF
    chmod +x tests/sanity/basic.sh

    cat > tests/smoke/quick.sh <<'BASH_EOF'
#!/usr/bin/env bash
# tests/smoke/quick.sh - Quick smoke tests

PROJECT_SCRIPT="./$name.sh"

test_script_executable() {
    [[ -x "\$PROJECT_SCRIPT" ]] || { echo "Script not executable"; return 1; }
    echo "Script is executable"
    return 0
}

test_help_command() {
    if ! "\$PROJECT_SCRIPT" --help >/dev/null 2>&1; then
        echo "Help command failed"
        return 1
    fi
    echo "Help command works"
    return 0
}

test_version_command() {
    if ! "\$PROJECT_SCRIPT" version >/dev/null 2>&1; then
        echo "Version command failed"
        return 1
    fi
    echo "Version command works"
    return 0
}

# Run tests
test_script_executable
test_help_command
test_version_command
BASH_EOF
    chmod +x tests/smoke/quick.sh

    # Create adhoc skeleton
    info "Creating adhoc test skeleton..."
    cat > tests/_adhoc/demo.sh <<'ADHOC_EOF'
#!/usr/bin/env bash
# tests/_adhoc/demo.sh - Example adhoc test for $name

echo "This is an adhoc test for $name"
echo "Testing specific functionality or edge cases"

# Example test
if [[ -f "./$name.sh" ]]; then
    echo "Project script found"
else
    echo "Project script missing - run build.sh first"
    exit 1
fi

exit 0
ADHOC_EOF
    chmod +x tests/_adhoc/demo.sh

    okay "TESTSH structure bootstrapped for bash project"
    info "Run '../test.sh list' to see available test categories"
    info "Run '../test.sh bootstrap' to regenerate this structure"
}

main "\$@"
EOF
}

__print_testsh_bash_examples() {
    local target_dir="$1"
    local name="$2"

    # Create comprehensive examples for bash testing
    cat > "$target_dir/tests/unit/functions.sh" << EOF
#!/usr/bin/env bash
# tests/unit/functions.sh - Unit tests for individual functions

# This would test individual functions from your script
# Note: BashFX scripts are typically tested via CLI rather than sourcing

echo "Unit testing individual functions (if applicable)"

# Example: If you expose functions for testing
# test_validate_input() {
#     # Test input validation logic
#     return 0
# }

exit 0
EOF
    chmod +x "$target_dir/tests/unit/functions.sh"

    cat > "$target_dir/tests/integration/workflow.sh" << EOF
#!/usr/bin/env bash
# tests/integration/workflow.sh - Integration workflow tests

PROJECT_SCRIPT="./$name.sh"

test_complete_workflow() {
    echo "Testing complete workflow integration"

    # Example workflow test
    if ! "\$PROJECT_SCRIPT" demo >/dev/null 2>&1; then
        echo "Demo workflow failed"
        return 1
    fi

    echo "Integration workflow passed"
    return 0
}

test_complete_workflow
EOF
    chmod +x "$target_dir/tests/integration/workflow.sh"
}