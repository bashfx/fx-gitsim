################################################################################
# BashFX Template Module
################################################################################

# Register this template with the core system
_register_template "bash" "BashFX-compliant script project" "sh bashfx"

################################################################################
# BashFX Template Implementation
################################################################################

# Main creation function (standard interface)
_create_bash_template() {
    local target_dir="$1"
    local project_name="$2"
    
    # Create BashFX project structure
    mkdir -p "$target_dir"/{parts,tests}
    
    # Generate BashFX project files
    __print_bashfx_script "$target_dir/${project_name}.sh" "$project_name"
    __print_bashfx_buildmap "$target_dir/parts/build.map"
    __print_bashfx_header "$target_dir/parts/01_header.sh" "$project_name"
    __print_bashfx_main "$target_dir/parts/02_main.sh" "$project_name"
    __print_bashfx_build_script "$target_dir/build.sh" "$project_name"
    __print_bash_test_runner "$target_dir/test_runner.sh" "$project_name"
    __print_bash_gitignore "$target_dir/.gitignore"
    __print_readme_md "$target_dir/README.md" "$project_name" "BashFX"
    
    # Make scripts executable
    chmod +x "$target_dir/${project_name}.sh"
    chmod +x "$target_dir/build.sh"
    chmod +x "$target_dir/test_runner.sh"
    
    trace "Created BashFX project structure in $target_dir"
    return 0
}

# Template preview function
_show_bash_template() {
    cat << 'EOF'
BashFX project structure:
  project.sh          - Main BashFX-compliant script
  build.sh            - Modular build system
  parts/
    build.map         - Build configuration
    01_header.sh      - Script header with metadata
    02_main.sh        - Main function and execution
  tests/
  test_runner.sh      - Test framework
  .gitignore          - Bash-specific ignore patterns  
  README.md           - Project documentation

Features: Full BashFX 2.0 compliance, modular build system, proper function ordinality
EOF
}

################################################################################
# BashFX File Generators
################################################################################

__print_bashfx_script() {
    local file="$1"
    local name="$2"
    
    cat > "$file" << EOF
#!/usr/bin/env bash
#
# $name - BashFX-Compliant Script
#
# name: $name
# version: 1.0.0
# desc: Sample BashFX-compliant script generated by GitSim
# author: $SIM_USER
#
# portable: grep, sed, awk, find
# builtins: printf, read, local, declare, case, if, for, while, shift, return

################################################################################
# Configuration & Standards
################################################################################

readonly SCRIPT_NAME="$name"
readonly SCRIPT_VERSION="1.0.0"

# XDG+ Configuration
: \${XDG_HOME:="\$HOME/.local"}
: \${XDG_DATA_HOME:="\$XDG_HOME/data"}
: \${XDG_CONFIG_HOME:="\$HOME/.config"}

# Standard option flags
opt_debug=false
opt_trace=false
opt_quiet=false
opt_force=false
opt_yes=false

################################################################################
# stderr functions
################################################################################

stderr() { printf "%s\\n" "\$*" >&2; }
info() { [[ "\$opt_quiet" == true ]] && return; stderr "[INFO] \$*"; }
warn() { [[ "\$opt_quiet" == true ]] && return; stderr "[WARN] \$*"; }
error() { stderr "[ERROR] \$*"; }
fatal() { stderr "[FATAL] \$*"; exit 1; }
okay() { [[ "\$opt_quiet" == true ]] && return; stderr "[OK] \$*"; }
trace() { [[ "\$opt_trace" == true ]] && stderr "[TRACE] \$*"; }

################################################################################
# Helper Functions
################################################################################

_logo() {
    cat << 'LOGO_EOF'
 _____ _____ _____ _____ 
|   __|     | __  |     |
|__   |   --|    -|-   -|
|_____|_____|__|__|_____|
$name v$SCRIPT_VERSION
LOGO_EOF
}

_validate_input() {
    local input="\$1"
    
    if [[ -z "\$input" ]]; then
        error "Input required"
        return 1
    fi
    
    return 0
}

################################################################################
# Dispatchable Functions (High-Order)
################################################################################

do_hello() {
    local name="\${1:-World}"
    
    if ! _validate_input "\$name"; then
        return 1
    fi
    
    okay "Hello, \$name from \$SCRIPT_NAME!"
    trace "Greeting completed for: \$name"
    return 0
}

do_demo() {
    info "Running \$SCRIPT_NAME demonstration"
    
    _logo
    
    printf "\\nThis is a BashFX-compliant script with:\\n"
    printf "- Proper function ordinality\\n"
    printf "- XDG+ directory compliance\\n"
    printf "- Standard option parsing\\n"
    printf "- Modular build system support\\n"
    printf "- Comprehensive error handling\\n"
    
    okay "Demo completed successfully"
    return 0
}

do_status() {
    printf "Script: %s\\n" "\$SCRIPT_NAME"
    printf "Version: %s\\n" "\$SCRIPT_VERSION"
    printf "Author: %s\\n" "$SIM_USER"
    printf "Debug: %s\\n" "\$opt_debug"
    printf "Quiet: %s\\n" "\$opt_quiet"
    printf "XDG_HOME: %s\\n" "\$XDG_HOME"
    return 0
}

do_version() {
    printf "%s v%s\\n" "\$SCRIPT_NAME" "\$SCRIPT_VERSION"
    return 0
}

################################################################################
# Core System Functions  
################################################################################

dispatch() {
    local cmd="\$1"
    shift
    
    case "\$cmd" in
        hello)   do_hello "\$@";;
        demo)    do_demo "\$@";;
        status)  do_status "\$@";;
        version) do_version "\$@";;
        *)
            error "Unknown command: \$cmd"
            usage
            return 1
            ;;
    esac
}

usage() {
    cat << 'USAGE_EOF'
$name - BashFX-Compliant Script

USAGE:
    $name <command> [options] [args]

COMMANDS:
    hello [name]        Greet someone (default: World)
    demo               Run demonstration
    status             Show script status
    version            Show version information

OPTIONS:
    -d, --debug        Enable debug output
    -t, --trace        Enable trace output (implies -d)
    -q, --quiet        Suppress all output except errors
    -f, --force        Force operations, bypass safety checks
    -y, --yes          Automatically answer yes to prompts

EXAMPLES:
    $name hello Alice
    $name demo
    $name status
    
This script follows BashFX 2.0 architecture standards.
    
USAGE_EOF
}

options() {
    local this next opts=("\$@")
    for ((i=0; i<\${#opts[@]}; i++)); do
        this=\${opts[i]}
        next=\${opts[i+1]}
        case "\$this" in
            -d|--debug)
                opt_debug=true
                ;;
            -t|--trace)
                opt_trace=true
                opt_debug=true
                ;;
            -q|--quiet)
                opt_quiet=true
                ;;
            -f|--force)
                opt_force=true
                ;;
            -y|--yes)
                opt_yes=true
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            *)
                :
                ;;
        esac
    done
}

main() {
    # Show logo unless quiet
    if [[ "\$opt_quiet" != true ]]; then
        _logo
        printf "\\n"
    fi
    
    # Show help if no command provided
    if [[ \${#@} -eq 0 ]]; then
        usage
        exit 0
    fi
    
    # Dispatch to command
    dispatch "\$@"
}

# Script execution using BashFX pattern
if [ "\$0" = "-bash" ]; then
    :
else
    # direct call
    orig_args=("\$@")
    options "\${orig_args[@]}"
    args=("\${orig_args[@]##-*}") # delete anything that looks like an option
    main "\${args[@]}"
    ret=\$?
fi
EOF
}

__print_bashfx_buildmap() {
    local file="$1"
    
    cat > "$file" << 'EOF'
# Build Map for BashFX Project
# Format: NN : target_filename.sh
# Lines starting with # are ignored
# Place this file in: parts/build.map

01 : 01_header.sh
02 : 02_main.sh
EOF
}

__print_bashfx_header() {
    local file="$1"
    local name="$2"
    
    cat > "$file" << EOF
#!/usr/bin/env bash
#
# $name - BashFX-Compliant Script
#
# name: $name
# version: 1.0.0
# desc: Sample BashFX-compliant script generated by GitSim
# author: $SIM_USER
#
# portable: grep, sed, awk, find
# builtins: printf, read, local, declare, case, if, for, while, shift, return
EOF
}

__print_bashfx_main() {
    local file="$1"
    local name="$2"
    
    cat > "$file" << EOF
main() {
    # Show logo unless quiet
    if [[ "\$opt_quiet" != true ]]; then
        _logo
        printf "\\n"
    fi
    
    # Show help if no command provided
    if [[ \${#@} -eq 0 ]]; then
        usage
        exit 0
    fi
    
    # Dispatch to command
    dispatch "\$@"
}

# Script execution using BashFX pattern
if [ "\$0" = "-bash" ]; then
    :
else
    # direct call
    orig_args=("\$@")
    options "\${orig_args[@]}"
    args=("\${orig_args[@]##-*}") # delete anything that looks like an option
    main "\${args[@]}"
    ret=\$?
fi
EOF
}

__print_bashfx_build_script() {
    local file="$1"
    local name="$2"
    
    cat > "$file" << EOF
#!/usr/bin/env bash
#
# build.sh - BashFX Build Script for $name
#

# Configuration
OUTPUT_FILE="$name.sh"
PARTS_DIR="parts"
BUILD_MAP="\$PARTS_DIR/build.map"
BACKUP_SUFFIX=".bak"

# Colors for output
readonly RED=\$'\\033[31m'
readonly GREEN=\$'\\033[32m' 
readonly YELLOW=\$'\\033[33m'
readonly BLUE=\$'\\033[34m'
readonly RESET=\$'\\033[0m'

# Logging functions
info() { printf "%s[INFO]%s %s\\n" "\$BLUE" "\$RESET" "\$*" >&2; }
okay() { printf "%s[OK]%s %s\\n" "\$GREEN" "\$RESET" "\$*" >&2; }
warn() { printf "%s[WARN]%s %s\\n" "\$YELLOW" "\$RESET" "\$*" >&2; }
error() { printf "%s[ERROR]%s %s\\n" "\$RED" "\$RESET" "\$*" >&2; }
fatal() { error "\$*"; exit 1; }

# Validate build environment
check_environment() {
    [[ -d "\$PARTS_DIR" ]] || fatal "Parts directory '\$PARTS_DIR' not found"
    [[ -f "\$BUILD_MAP" ]] || fatal "Build map '\$BUILD_MAP' not found"
    info "Environment validated"
}

# Build the output file from parts
build_script() {
    local temp_file="\${OUTPUT_FILE}.tmp"
    local parts_used=0
    
    info "Building \$OUTPUT_FILE from parts..."
    
    # Create temporary file
    > "\$temp_file"
    
    # Process build map
    while IFS= read -r line; do
        # Skip comments and empty lines
        [[ "\$line" =~ ^\[[:space:\]\]*# ]] && continue
        [[ -z "\${line// }" ]] && continue
        
        # Parse map entry: "NN : filename.sh"
        if [[ "\$line" =~ ^([0-9]+)[[:space:]]*:[[:space:]]*(.+)\$ ]]; then
            local part_num="\${BASH_REMATCH[1]}"
            local part_file="\${BASH_REMATCH[2]// /}" # Remove spaces
            local part_path="\$PARTS_DIR/\$part_file"
            
            if [[ -f "\$part_path" ]]; then
                info "Adding part \$part_num: \$part_file"
                cat "\$part_path" >> "\$temp_file"
                echo >> "\$temp_file"  # Add newline between parts
                ((parts_used++))
            else
                warn "Part file not found: \$part_path"
            fi
        fi
    done < "\$BUILD_MAP"
    
    if [[ \$parts_used -eq 0 ]]; then
        fatal "No parts were processed"
    fi
    
    # Backup existing file if it exists
    if [[ -f "\$OUTPUT_FILE" ]]; then
        cp "\$OUTPUT_FILE" "\${OUTPUT_FILE}\${BACKUP_SUFFIX}"
        info "Backed up existing file to \${OUTPUT_FILE}\${BACKUP_SUFFIX}"
    fi
    
    # Move temp file to final location
    mv "\$temp_file" "\$OUTPUT_FILE"
    chmod +x "\$OUTPUT_FILE"
    
    okay "Built \$OUTPUT_FILE from \$parts_used parts"
}

# Main execution
main() {
    case "\${1:-build}" in
        build)
            check_environment
            build_script
            ;;
        clean)
            rm -f "\${OUTPUT_FILE}.tmp" "\${OUTPUT_FILE}\${BACKUP_SUFFIX}"
            okay "Cleaned build artifacts"
            ;;
        *)
            echo "Usage: \$0 [build|clean]"
            exit 1
            ;;
    esac
}

main "\$@"
EOF
}

__print_bash_test_runner() {
    local file="$1"
    local name="$2"
    
    cat > "$file" << EOF
#!/usr/bin/env bash
# test_runner.sh - Test Framework for $name

set -e

# Test configuration
readonly TEST_SCRIPT="./$name.sh"
readonly RED=\$'\\033[31m'
readonly GREEN=\$'\\033[32m'
readonly RESET=\$'\\033[0m'

# Test counters
TESTS_RUN=0
TESTS_PASSED=0
TESTS_FAILED=0

echo "=== Running Tests for $name ==="
echo

# Test framework functions
test_start() {
    local description="\$1"
    printf "Testing: %s ... " "\$description"
    ((TESTS_RUN++))
}

test_pass() {
    printf "%s✓ PASS%s\\n" "\$GREEN" "\$RESET"
    ((TESTS_PASSED++))
}

test_fail() {
    local message="\$1"
    printf "%s✗ FAIL%s" "\$RED" "\$RESET"
    [[ -n "\$message" ]] && printf " - %s" "\$message"
    printf "\\n"
    ((TESTS_FAILED++))
}

# Individual test functions
test_version() {
    test_start "version command"
    local output
    if output=\$("\$TEST_SCRIPT" version 2>&1); then
        if [[ "\$output" == *"$name v1.0.0"* ]]; then
            test_pass
        else
            test_fail "Expected version string not found"
        fi
    else
        test_fail "Command failed"
    fi
}

test_hello() {
    test_start "hello command"
    local output
    if output=\$("\$TEST_SCRIPT" hello Alice 2>&1); then
        if [[ "\$output" == *"Hello, Alice"* ]]; then
            test_pass
        else
            test_fail "Expected greeting not found"
        fi
    else
        test_fail "Command failed"
    fi
}

test_demo() {
    test_start "demo command"
    local output
    if output=\$("\$TEST_SCRIPT" demo 2>&1); then
        if [[ "\$output" == *"demonstration"* ]]; then
            test_pass
        else
            test_fail "Demo output not as expected"
        fi
    else
        test_fail "Command failed"
    fi
}

test_status() {
    test_start "status command"
    local output
    if output=\$("\$TEST_SCRIPT" status 2>&1); then
        if [[ "\$output" == *"Script: $name"* ]]; then
            test_pass
        else
            test_fail "Status output not as expected"
        fi
    else
        test_fail "Command failed"
    fi
}

test_invalid_command() {
    test_start "invalid command handling"
    local output
    if output=\$("\$TEST_SCRIPT" invalid_command 2>&1); then
        # Should fail (return non-zero)
        test_fail "Command should have failed"
    else
        if [[ "\$output" == *"Unknown command"* ]]; then
            test_pass
        else
            test_fail "Expected error message not found"
        fi
    fi
}

test_help() {
    test_start "help output"
    local output
    if output=\$("\$TEST_SCRIPT" --help 2>&1); then
        if [[ "\$output" == *"USAGE:"* ]] && [[ "\$output" == *"COMMANDS:"* ]]; then
            test_pass
        else
            test_fail "Help format not as expected"
        fi
    else
        test_fail "Help command failed"
    fi
}

# Run all tests
run_tests() {
    # Check if script exists
    if [[ ! -f "\$TEST_SCRIPT" ]]; then
        echo "Error: Test script \$TEST_SCRIPT not found"
        echo "Run 'build.sh' first to create the script"
        exit 1
    fi
    
    # Run individual tests
    test_version
    test_hello
    test_demo
    test_status
    test_invalid_command
    test_help
}

# Show results
show_results() {
    echo
    echo "=== Test Results ==="
    printf "Tests run: %d\\n" "\$TESTS_RUN"
    printf "%sPassed: %d%s\\n" "\$GREEN" "\$TESTS_PASSED" "\$RESET"
    
    if [[ \$TESTS_FAILED -gt 0 ]]; then
        printf "%sFailed: %d%s\\n" "\$RED" "\$TESTS_FAILED" "\$RESET"
        echo
        echo "❌ Some tests failed"
        exit 1
    else
        echo
        echo "✅ All tests passed!"
    fi
}

# Main execution
main() {
    run_tests
    show_results
}

main "\$@"
EOF
}

__print_bash_gitignore() {
    local file="$1"
    
    cat > "$file" << 'EOF'
# Build artifacts
*.tmp
*.bak
build/
dist/

# BashFX build system
parts/*.tmp
EOF
    
    # Add common patterns
    __print_common_gitignore "$file"
}