################################################################################
# Node.js Template Module
################################################################################

# Register this template with the core system
_register_template "node" "Node.js project with npm" "js javascript npm"

################################################################################
# Node.js Template Implementation
################################################################################

# Main creation function (standard interface)
_create_node_template() {
    local target_dir="$1" 
    local project_name="$2"
    
    # Create Node.js project structure
    mkdir -p "$target_dir"/{src,test,config}
    
    # Generate Node.js project files
    __print_package_json "$target_dir/package.json" "$project_name"
    __print_node_index "$target_dir/src/index.js" "$project_name"
    __print_node_server "$target_dir/src/server.js" "$project_name"
    __print_node_utils "$target_dir/src/utils.js" "$project_name"
    __print_node_test "$target_dir/test/index.test.js" "$project_name"
    __print_node_config "$target_dir/config/default.json" "$project_name"
    __print_node_gitignore "$target_dir/.gitignore"
    __print_node_eslintrc "$target_dir/.eslintrc.js"
    __print_node_nvmrc "$target_dir/.nvmrc"
    __print_readme_md "$target_dir/README.md" "$project_name" "Node.js"
    
    # Generate fake package-lock.json for realism
    __print_package_lock_json "$target_dir/package-lock.json" "$project_name"
    
    trace "Created Node.js project structure in $target_dir"
    return 0
}

# Template preview function
_show_node_template() {
    cat << 'EOF'
Node.js project structure:
  package.json        - NPM package manifest with scripts
  package-lock.json   - Dependency lock file
  src/
    index.js          - Main application entry point
    server.js         - Express server implementation  
    utils.js          - Utility functions
  test/
    index.test.js     - Test suite
  config/
    default.json      - Configuration file
  .eslintrc.js        - ESLint configuration
  .nvmrc              - Node version specification
  .gitignore          - Node-specific ignore patterns
  README.md           - Project documentation

Dependencies: express, lodash, config
Dev Dependencies: jest, eslint, nodemon
EOF
}

################################################################################
# Node.js File Generators
################################################################################

__print_package_json() {
    local file="$1"
    local name="$2"
    
    cat > "$file" << EOF
{
  "name": "$name",
  "version": "1.0.0",
  "description": "A sample Node.js project generated by GitSim",
  "main": "src/index.js",
  "scripts": {
    "start": "node src/index.js",
    "dev": "nodemon src/index.js",
    "server": "node src/server.js",
    "test": "jest",
    "test:watch": "jest --watch",
    "lint": "eslint src/ test/",
    "lint:fix": "eslint src/ test/ --fix",
    "build": "echo 'Build step would go here'",
    "clean": "rm -rf node_modules package-lock.json"
  },
  "keywords": [
    "nodejs",
    "express",
    "sample",
    "gitsim"
  ],
  "author": "$SIM_USER",
  "license": "MIT",
  "dependencies": {
    "express": "^4.18.2",
    "lodash": "^4.17.21",
    "config": "^3.3.9",
    "cors": "^2.8.5",
    "helmet": "^7.0.0"
  },
  "devDependencies": {
    "jest": "^29.6.2",
    "eslint": "^8.45.0",
    "nodemon": "^3.0.1",
    "supertest": "^6.3.3"
  },
  "engines": {
    "node": ">=16.0.0",
    "npm": ">=8.0.0"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/${SIM_USER}/${name}.git"
  },
  "jest": {
    "testEnvironment": "node",
    "collectCoverageFrom": [
      "src/**/*.js"
    ],
    "coverageDirectory": "coverage"
  }
}
EOF
}

__print_node_index() {
    local file="$1"
    local name="$2"
    
    cat > "$file" << EOF
// $name - Main application entry point
const config = require('config');
const { createGreeting, formatMessage } = require('./utils');

/**
 * Main application class
 */
class Application {
    constructor(options = {}) {
        this.name = '$name';
        this.version = '1.0.0';
        this.config = { ...config, ...options };
    }

    /**
     * Initialize the application
     */
    async initialize() {
        console.log(formatMessage('info', \`Initializing \${this.name} v\${this.version}\`));
        
        // Simulate some startup tasks
        await this.loadConfiguration();
        await this.setupServices();
        
        console.log(formatMessage('success', 'Application initialized successfully'));
    }

    /**
     * Load configuration
     */
    async loadConfiguration() {
        console.log(formatMessage('info', 'Loading configuration...'));
        
        // Simulate async config loading
        await new Promise(resolve => setTimeout(resolve, 100));
        
        this.config.loaded = true;
    }

    /**
     * Setup services
     */
    async setupServices() {
        console.log(formatMessage('info', 'Setting up services...'));
        
        // Simulate service setup
        await new Promise(resolve => setTimeout(resolve, 50));
        
        this.services = {
            database: { connected: true },
            cache: { connected: true },
            logger: { initialized: true }
        };
    }

    /**
     * Run the main application logic
     */
    async run() {
        try {
            await this.initialize();
            
            // Main application logic
            const greeting = createGreeting('$name User');
            console.log(greeting);
            
            console.log('\\nApplication Status:');
            console.log(\`- Name: \${this.name}\`);
            console.log(\`- Version: \${this.version}\`);
            console.log(\`- Environment: \${process.env.NODE_ENV || 'development'}\`);
            console.log(\`- Services: \${Object.keys(this.services).join(', ')}\`);
            
            console.log(formatMessage('success', 'Application completed successfully'));
            
        } catch (error) {
            console.error(formatMessage('error', \`Application failed: \${error.message}\`));
            process.exit(1);
        }
    }

    /**
     * Graceful shutdown
     */
    async shutdown() {
        console.log(formatMessage('info', 'Shutting down application...'));
        
        // Cleanup logic would go here
        await new Promise(resolve => setTimeout(resolve, 100));
        
        console.log(formatMessage('success', 'Application shutdown complete'));
    }
}

// Run if called directly
if (require.main === module) {
    const app = new Application();
    
    // Handle graceful shutdown
    process.on('SIGINT', async () => {
        console.log('\\n'); // New line after ^C
        await app.shutdown();
        process.exit(0);
    });
    
    process.on('SIGTERM', async () => {
        await app.shutdown();
        process.exit(0);
    });
    
    // Start the application
    app.run().catch(error => {
        console.error('Unhandled error:', error);
        process.exit(1);
    });
}

module.exports = Application;
EOF
}

__print_node_server() {
    local file="$1"
    local name="$2"
    
    cat > "$file" << EOF
// $name - Express server implementation
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const config = require('config');
const { createGreeting, formatMessage } = require('./utils');

/**
 * Server class for $name
 */
class Server {
    constructor(options = {}) {
        this.app = express();
        this.port = options.port || config.get('server.port') || 3000;
        this.host = options.host || config.get('server.host') || 'localhost';
        
        this.setupMiddleware();
        this.setupRoutes();
        this.setupErrorHandling();
    }

    /**
     * Setup middleware
     */
    setupMiddleware() {
        // Security middleware
        this.app.use(helmet());
        this.app.use(cors());
        
        // Body parsing
        this.app.use(express.json({ limit: '10mb' }));
        this.app.use(express.urlencoded({ extended: true }));
        
        // Request logging
        this.app.use((req, res, next) => {
            console.log(formatMessage('info', \`\${req.method} \${req.path}\`));
            next();
        });
    }

    /**
     * Setup routes
     */
    setupRoutes() {
        // Health check
        this.app.get('/health', (req, res) => {
            res.json({
                service: '$name',
                status: 'healthy',
                timestamp: new Date().toISOString(),
                uptime: process.uptime(),
                version: '1.0.0'
            });
        });

        // Root endpoint
        this.app.get('/', (req, res) => {
            res.json({
                message: createGreeting('API'),
                service: '$name',
                version: '1.0.0',
                endpoints: [
                    'GET /',
                    'GET /health',
                    'GET /greet/:name',
                    'POST /echo',
                    'GET /status'
                ]
            });
        });

        // Greeting endpoint
        this.app.get('/greet/:name', (req, res) => {
            const { name } = req.params;
            const greeting = createGreeting(name);
            
            res.json({
                greeting,
                timestamp: new Date().toISOString(),
                requestedName: name
            });
        });

        // Echo endpoint
        this.app.post('/echo', (req, res) => {
            res.json({
                echo: req.body,
                timestamp: new Date().toISOString(),
                headers: req.headers
            });
        });

        // Status endpoint
        this.app.get('/status', (req, res) => {
            res.json({
                service: '$name',
                status: 'running',
                environment: process.env.NODE_ENV || 'development',
                nodejs: process.version,
                memory: process.memoryUsage(),
                uptime: process.uptime(),
                timestamp: new Date().toISOString()
            });
        });
    }

    /**
     * Setup error handling
     */
    setupErrorHandling() {
        // 404 handler
        this.app.use((req, res) => {
            res.status(404).json({
                error: 'Not Found',
                message: \`Route \${req.method} \${req.path} not found\`,
                timestamp: new Date().toISOString()
            });
        });

        // Error handler
        this.app.use((error, req, res, next) => {
            console.error(formatMessage('error', \`Server error: \${error.message}\`));
            
            res.status(500).json({
                error: 'Internal Server Error',
                message: 'Something went wrong',
                timestamp: new Date().toISOString()
            });
        });
    }

    /**
     * Start the server
     */
    async start() {
        return new Promise((resolve, reject) => {
            this.server = this.app.listen(this.port, this.host, (error) => {
                if (error) {
                    reject(error);
                } else {
                    console.log(formatMessage('success', \`Server running at http://\${this.host}:\${this.port}\`));
                    resolve(this.server);
                }
            });
        });
    }

    /**
     * Stop the server
     */
    async stop() {
        if (this.server) {
            return new Promise((resolve) => {
                this.server.close(() => {
                    console.log(formatMessage('info', 'Server stopped'));
                    resolve();
                });
            });
        }
    }
}

// Run if called directly
if (require.main === module) {
    const server = new Server();
    
    // Handle graceful shutdown
    const shutdown = async () => {
        console.log('\\nShutting down server...');
        await server.stop();
        process.exit(0);
    };
    
    process.on('SIGINT', shutdown);
    process.on('SIGTERM', shutdown);
    
    // Start server
    server.start().catch(error => {
        console.error('Failed to start server:', error);
        process.exit(1);
    });
}

module.exports = Server;
EOF
}

__print_node_utils() {
    local file="$1"
    local name="$2"
    
    cat > "$file" << EOF
// $name - Utility functions
const _ = require('lodash');

/**
 * Create a greeting message
 * @param {string} name - Name to greet
 * @returns {string} Greeting message
 */
function createGreeting(name) {
    if (!name || typeof name !== 'string') {
        throw new Error('Name must be a non-empty string');
    }
    
    const capitalizedName = _.capitalize(name.trim());
    return \`Hello, \${capitalizedName}! Welcome to $name.\`;
}

/**
 * Format a log message with timestamp and level
 * @param {string} level - Log level (info, warn, error, success)
 * @param {string} message - Message to format
 * @returns {string} Formatted message
 */
function formatMessage(level, message) {
    const timestamp = new Date().toISOString();
    const levelUpper = level.toUpperCase().padEnd(7);
    
    // Add color codes for terminal output
    const colors = {
        info: '\\x1b[36m',    // Cyan
        warn: '\\x1b[33m',    // Yellow
        error: '\\x1b[31m',   // Red
        success: '\\x1b[32m', // Green
        reset: '\\x1b[0m'     // Reset
    };
    
    const color = colors[level] || colors.reset;
    const reset = colors.reset;
    
    return \`[\${timestamp}] \${color}\${levelUpper}\${reset} \${message}\`;
}

/**
 * Validate email address
 * @param {string} email - Email to validate
 * @returns {boolean} True if valid email
 */
function isValidEmail(email) {
    if (!email || typeof email !== 'string') {
        return false;
    }
    
    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+\$/;
    return emailRegex.test(email);
}

/**
 * Deep merge objects
 * @param {Object} target - Target object
 * @param {...Object} sources - Source objects
 * @returns {Object} Merged object
 */
function deepMerge(target, ...sources) {
    return _.mergeWith(target, ...sources, (objValue, srcValue) => {
        if (_.isArray(objValue)) {
            return objValue.concat(srcValue);
        }
    });
}

/**
 * Generate a random ID
 * @param {number} length - Length of ID (default: 8)
 * @returns {string} Random ID
 */
function generateId(length = 8) {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    let result = '';
    
    for (let i = 0; i < length; i++) {
        result += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    
    return result;
}

/**
 * Sleep for specified milliseconds
 * @param {number} ms - Milliseconds to sleep
 * @returns {Promise} Promise that resolves after delay
 */
function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * Retry a function with exponential backoff
 * @param {Function} fn - Function to retry
 * @param {number} maxRetries - Maximum retry attempts
 * @param {number} baseDelay - Base delay in milliseconds
 * @returns {Promise} Promise that resolves with function result
 */
async function retryWithBackoff(fn, maxRetries = 3, baseDelay = 1000) {
    let lastError;
    
    for (let attempt = 0; attempt <= maxRetries; attempt++) {
        try {
            return await fn();
        } catch (error) {
            lastError = error;
            
            if (attempt === maxRetries) {
                throw error;
            }
            
            const delay = baseDelay * Math.pow(2, attempt);
            console.log(formatMessage('warn', \`Retry attempt \${attempt + 1}/\${maxRetries} after \${delay}ms\`));
            await sleep(delay);
        }
    }
    
    throw lastError;
}

module.exports = {
    createGreeting,
    formatMessage,
    isValidEmail,
    deepMerge,
    generateId,
    sleep,
    retryWithBackoff
};
EOF
}
    